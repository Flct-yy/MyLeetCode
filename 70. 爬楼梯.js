/**
/**
 * a(n) = a(n-1) + a(n-2)
 * 如果直接递归，会重复计算很多次 导致时间复杂度过高 (例如计算 a(5) 时，a(3) 会被计算 2 次)
 * 所以 可以保存已经计算过的结果 来避免重复计算 (这是动态规划的核心思想：记忆化)
 * 但是 这样会占用较多的空间 (如果用一个数组来存储所有子问题的解，空间复杂度是 O(n))
 * 通过发现 每次计算 只用前两个数据 所以我们只需要保存前两个数据就行 (优化空间)
 * @param {number} n - 楼梯的阶数
 * @return {number} - 爬到楼顶的不同方法数
 */
var climbStairs = function (n) {
  // 用三个变量来保存前两个数据 和 当前数据
  // p 保存 a(n-2) q 保存 a(n-1) r 保存 a(n)
  let p = 0, q = 0, r = 1;
  // 循环从 1 到 n (包含 n)
  // 每一次循环，我们都计算出当前 i 阶的方法数 r
  for (let i = 1; i <= n; i++) {
    // 1. 将 q 的值（上一轮的 a(n-1)）赋给 p，现在 p 代表 a(i-2)
    p = q;

    // 2. 将 r 的值（上一轮的 a(n)）赋给 q，现在 q 代表 a(i-1)
    q = r;

    // 3. 计算新的 r，即当前 i 阶的方法数：a(i) = a(i-1) + a(i-2)
    r = p + q;
  }

  // 循环结束后，r 中存储的就是 a(n) 的值
  return r;

};